<!doctype html>
<!-- 데모용 단일 HTML. API Base/Bot ID 입력을 localStorage에 보관하여 새로고침 후 유지 -->
<!-- 응답 아래 latencyMs/토큰 표시로 성능/비용 감을 제공. CORS/포트 일치 필요(127.0.0.1 vs localhost 혼용 주의). -->
<html lang="ko">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Chat • BOT_123</title>
    <style>
        :root {
            --bg: #fafafa;
            --card: #fff;
            --bd: #e5e7eb;
            --text: #111;
            --muted: #6b7280;
        }

        * {
            box-sizing: border-box
        }

        body {
            font-family: ui-sans-serif, system-ui;
            margin: 0;
            padding: 24px;
            background: var(--bg)
        }

        .wrap {
            max-width: 720px;
            margin: 0 auto
        }

        .box {
            height: 60vh;
            overflow: auto;
            border: 1px solid var(--bd);
            background: var(--card);
            border-radius: 12px;
            padding: 12px
        }

        .msg {
            margin: 8px 0;
            line-height: 1.45
        }

        .user {
            text-align: right
        }

        .assistant {
            text-align: left;
            white-space: pre-wrap
        }

        .meta {
            color: var(--muted);
            font-size: 12px;
            margin-top: 2px
        }

        .error {
            color: #b91c1c;
            white-space: pre-wrap
        }

        form {
            display: flex;
            gap: 8px;
            margin-top: 12px
        }

        input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px
        }

        button {
            padding: 10px 16px;
            border: 0;
            border-radius: 8px;
            background: var(--text);
            color: #fff;
            cursor: pointer
        }

        button[disabled] {
            opacity: .6;
            cursor: not-allowed
        }

        .row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px
        }

        .row > input {
            flex: 1
        }
    </style>
</head>
<body>
<div class="wrap">
    <h1>Chat • BOT_123</h1>

    <!-- 환경 설정 행: API_BASE / BOT_ID -->
    <div class="row">
        <input id="apiBase" placeholder="API Base (예: http://127.0.0.1:9000)"/>
        <input id="botId" placeholder="Bot ID"/>
    </div>

    <div id="log" class="box" aria-live="polite"></div>

    <form id="f">
        <input id="q" type="text" placeholder="질문을 입력하세요" autocomplete="off"/>
        <button id="sendBtn" type="submit">보내기</button>
    </form>
</div>

<script>
    // ---- 사용자가 쉽게 바꿀 수 있게 기본값/쿼리스트링/로컬스토리지로 API_BASE/BOT_ID를 관리
    const qs = new URLSearchParams(location.search);
    const LS = {
        session: 'chat.sessionId',
        apiBase: 'chat.apiBase',
        botId: 'chat.botId',
    };

    const apiBaseInput = document.getElementById('apiBase');
    const botIdInput = document.getElementById('botId');

    const defaultApiBase = 'http://127.0.0.1:9000';
    const defaultBotId = 'BOT_123';

    apiBaseInput.value =
        qs.get('apiBase') ||
        localStorage.getItem(LS.apiBase) ||
        defaultApiBase;

    botIdInput.value =
        qs.get('botId') ||
        localStorage.getItem(LS.botId) ||
        defaultBotId;

    // 세션 유지: 서버에서 받은 sessionId를 localStorage에 저장해 대화 맥락 지속
    let sessionId = localStorage.getItem(LS.session) || null;

    const log = document.getElementById('log');
    const form = document.getElementById('f');
    const input = document.getElementById('q');
    const sendBtn = document.getElementById('sendBtn');

    // 메시지 버블 생성: 역할에 따라 정렬하고 latency/tokens 메타 정보를 함께 렌더링
    function addBubble(role, text, meta) {
        const wrap = document.createElement('div');
        wrap.className = `msg ${role}`;
        const line = document.createElement('div');
        line.textContent = text; // XSS 안전: textContent 사용
        wrap.appendChild(line);
        if (meta) {
            const m = document.createElement('div');
            m.className = 'meta';
            m.textContent = meta;
            wrap.appendChild(m);
        }
        log.appendChild(wrap);
        log.scrollTop = log.scrollHeight;
    }

    // 에러 메시지를 붉은색으로 표시해 사용자에게 즉시 피드백 제공
    function addError(text) {
        const wrap = document.createElement('div');
        wrap.className = 'msg assistant error';
        wrap.textContent = text;
        log.appendChild(wrap);
        log.scrollTop = log.scrollHeight;
    }

    // 서버에서 회신한 세션 ID를 저장해 이후 요청 시 reuse
    function saveSession(id) {
        if (!id) return;
        sessionId = id;
        localStorage.setItem(LS.session, id);
    }

    // 사용자가 API_BASE/BOT_ID 바꾸면 저장하여 새로고침 후에도 유지
    apiBaseInput.addEventListener('change', () => {
        localStorage.setItem(LS.apiBase, apiBaseInput.value.trim());
    });
    botIdInput.addEventListener('change', () => {
        localStorage.setItem(LS.botId, botIdInput.value.trim());
    });

    // fetch 타임아웃 유틸 (AbortController): 네트워크 지연 시 자동 취소하여 UI가 멈추지 않도록 함
    async function fetchWithTimeout(resource, options = {}) {
        const {timeout = 15000} = options;
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        try {
            const res = await fetch(resource, {...options, signal: controller.signal});
            return res;
        } finally {
            clearTimeout(id);
        }
    }

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const text = input.value.trim();
        if (!text) return;

        const apiBase = apiBaseInput.value.trim().replace(/\/$/, '');
        const botId = botIdInput.value.trim() || defaultBotId;
        const url = `${apiBase}/v1/chat`;

        // UI 즉시 업데이트: 사용자 메시지를 먼저 추가하고 입력창 초기화
        addBubble('user', text);
        input.value = '';
        sendBtn.disabled = true;
        const sendingAt = performance.now();

        try {
            // LLM 호출: latency 측정을 위해 시작 시각을 기록하고 fetchWithTimeout 사용
            const res = await fetchWithTimeout(url, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    botId,
                    message: text,
                    sessionId,
                    meta: {lang: navigator.language}
                }),
                timeout: 20000
            });

            // 2xx 아닌 경우 본문을 읽어 보여주기(검증 실패(400), CORS 오리진 미일치(403/401) 등)
            if (!res.ok) {
                const t = await res.text().catch(() => '');
                addError(`요청 실패: ${res.status} ${res.statusText}\n${t}`);
                return;
            }

            const data = await res.json();
            saveSession(data.sessionId);
            // latency와 토큰 추정치를 메타 정보로 표시해 사용자에게 비용/성능 피드백 제공
            const latency = typeof data.latencyMs === 'number'
                ? `${data.latencyMs} ms`
                : `${Math.round(performance.now() - sendingAt)} ms`;
            const tokens = data.usage
                ? `tokens p:${data.usage.promptTokens ?? '-'} c:${data.usage.completionTokens ?? '-'}`
                : '';
            addBubble('assistant', data.answer || '(응답 없음)', `${latency}${tokens ? ` • ${tokens}` : ''}`);

        } catch (err) {
            // 오류 처리: 타임아웃과 기타 예외를 구분해 사용자 메시지를 달리 출력
            if (err?.name === 'AbortError') {
                addError('요청이 타임아웃되었습니다. (네트워크 지연/서버 과부하)');
            } else {
                addError(`요청 중 오류가 발생했습니다: ${err}`);
            }
        } finally {
            // Finally: 버튼 상태를 원복하고 입력 포커스를 되돌려 빠른 재시도를 돕는다
            sendBtn.disabled = false;
            input.focus();
        }
    });

    // 처음 들어왔을 때 현재 설정 상태 안내: 사용자가 즉시 기능을 이해하도록 기본 도움말 표시
    addBubble('assistant',
        '안녕하세요! 메시지를 입력해 대화를 시작하세요.\n' +
        '- API Base: 상단 입력칸에서 변경 가능 (예: http://localhost:9000)\n' +
        '- 세션은 localStorage로 유지됩니다.'
    );
</script>
</body>
</html>
